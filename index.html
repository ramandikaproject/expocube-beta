<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Exposure Cube</title>
  
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=deployed_code" />
  <style>
    .material-symbols-outlined {
      font-variation-settings:
      'FILL' 0,
      'wght' 600,
      'GRAD' 0,
      'opsz' 40
    }
  </style>
  
  <link rel="stylesheet" href="style.css">
</head>

<body>
<div id="container">  
  

  <!-- Page Title -->

  <div class="page-title">

    <div class="page-title-left display-title">      
      <div class="title-name h1">
        <span>Exposure Cube</span>
        <div class="title-icon"><span class="material-symbols-outlined h1">deployed_code</span></div>
      </div>
      
      <div class="bottom">
        <span class="title-name p">A New Way to Understand Exposure</span> 
      </div>
    </div>

    <div class="page-title-right">
      <div></div>
      <div class="bottom title-creator">
        <span class="title-name p title-creator">by Ramandika Project</span>
      </div>
    </div>

  </div>

  <!--
  <div class="bottom title-desc">
    <p>Exposure Cube is a new concept that reimagines the traditional exposure triangle in photography by visualizing the relation between the three key elements: Shutter Speed, Aperture, and ISO, in the form of a 3D cube.</p>
    <p>This spatial approach allows users to intuitively grasp how changes in one element affect the other two, helping them manage exposure with greater precision.</p>
  </div>
  -->

  <!-- Page Intro -->
  
  <div class="tab-container">

    <div class="tab-buttons">
      <div class="intro-title">
        <span><h2>What is it?</h2></span>
      </div>

      <div class="tab-title">
        <button onclick="openTab('tab1')" class="active"><h2>English</h2></button>
        <button onclick="openTab('tab2')"><h2>Indonesia</h2></button>
      </div>

      <div class="filler01"></div>      
    </div>

    <div class="tab-content" id="tab1">
      <p><strong>Exposure Cube</strong> is a new concept that reimagines the traditional exposure triangle in photography by visualizing the relation between the three key elements: Shutter Speed, Aperture, and ISO, in the form of a 3D cube.</p>
      <p>This spatial approach allows users to intuitively grasp how changes in one element affect the other two, helping them manage exposure with greater precision.</p>
    </div>

    <div class="tab-content" id="tab2" style="display: none;">
      <p>This spatial approach allows users to intuitively grasp how changes in one element affect the other two, helping them manage exposure with greater precision.</p>
    </div>
  </div>
  
  
  <!-- Atas: Sistem Kubus -->

  <div id="cube-section">
    
    <div class="display-title section-title-1">
      <h2>
        Simulation
      </h2>

      <div class="container-section-2">
        <div class="display-title section-title-2 sistem-kubus">
          <h2>Kartesius Display</h2>
          <div class="display" id="three-container"></div>
        </div>
        
        <!-- Tombol Pengubah -->

        <div class="display-title section-title-2 sistem-kubus section-2-gap" id="">
          <div>
            <h2>Control</h2>

            <div class="control-frame">
              <div class="control-group" id="">
                <div class="control-group-title display-title">
                  <h4 id="redbg">Shutter Speed [X]</h4>
                  <div class="value-control">
                    <button onclick="changeValue('x', -1)">-</button>
                    <span class="value" id="x-value"> </span>
                    <button onclick="changeValue('x', 1)">+</button>
                  </div>
                </div>                
              </div>

              <div class="control-group" id="">
                <div class="control-group-title display-title">
                  <h4 class="black-text" id="greenbg">Aperture [Y]</h4>
                  <div class="value-control">
                    <button onclick="changeValue('y', -1)">-</button>
                    <span class="value" id="y-value"> </span>
                    <button onclick="changeValue('y', 1)">+</button>
                  </div>
                </div>                
              </div>

              <div class="control-group" id="">
                <div class="control-group-title display-title">
                  <h4 id="bluebg" >ISO [Z]</h4>
                  <div class="value-control">
                    <button onclick="changeValue('z', -1)">-</button>
                    <span class="value" id="z-value"> </span>
                    <button onclick="changeValue('z', 1)">+</button>
                  </div>
                </div>                
              </div>
            </div>

          </div> 
        </div>      
      </div>
    </div>
    
  </div>

  <!-- Bawah: Image Preview -->

  <div id="result-section">
    <div class="display-title section-title-1">
      <h2>
        Result
      </h2>

      <div class="container-section-2 container-image">
        
        <div class="display-title section-title-2">
          <h2>Image Preview</h2>
          <div class="image-group">
            <img src="assets/images/z01/y01___x01.JPG" alt="Preview Normal">
          </div>
        </div>

        <div class="display-title section-title-2 section-2-gap">
          <h2>Image Preview [4× zoom]</h2>
          <div class="image-group zoom">
            <img class="img-zoom" src="assets/images/z01/y01___x01.JPG" alt="Preview Normal">
          </div>
        </div>
        
      </div>

    </div>
    
  </div>

</div>

<!-- Three.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<!--  ########## ########## ########## ########## ##########  -->

<!-- Intro Tab -->

<script>
  function openTab(tabId) {
    // Sembunyikan semua tab
    const tabs = document.querySelectorAll(".tab-content");
    tabs.forEach(tab => tab.style.display = "none");

    // Hapus kelas aktif dari semua tombol
    const buttons = document.querySelectorAll(".tab-buttons button");
    buttons.forEach(btn => btn.classList.remove("active"));

    // Tampilkan tab yang dipilih dan aktifkan tombolnya
    document.getElementById(tabId).style.display = "block";
    event.currentTarget.classList.add("active");
  }
</script>

<!--  ########## ########## ########## ########## ##########  -->

<!-- Sistem Kubus -->

<script>
  // Variabel nilai
  /*
  const xLabels = 
  [' ','1/4000','1/1000','1/250','1/80','1/20','1/5','0"6','2"5','10"','30"'];
  const yLabels = 
  [' ','f/22','f/18','f/13','f/10','f/7.1','f/5.6','f/4.0','f/3.2','f/2.2','f/1.8'];
  const zLabels = 
  [' ','100','160','250','400','640','1000','1600','2500','4000','6400'];
  */

  // Variabel nilai Konstanta

  const x00 = ' ' ;
  const x01 = '1/4000' ;
  const x02 = '1/1000' ;
  const x03 = '1/250' ;
  const x04 = '1/80' ;
  const x05 = '1/20' ;
  const x06 = '1/5' ;
  const x07 = '0"6' ;
  const x08 = '2"5' ;
  const x09 = '10"' ;
  const x10 = '30"' ;

  const y00 = ' ' ;
  const y01 = 'f/22' ;
  const y02 = 'f/18' ;
  const y03 = 'f/13' ;
  const y04 = 'f/10' ;
  const y05 = 'f/7.1' ;
  const y06 = 'f/5.6' ;
  const y07 = 'f/4.0' ;
  const y08 = 'f/3.2' ;
  const y09 = 'f/2.2' ;
  const y10 = 'f/1.8' ;

  const z00 = ' ' ;
  const z01 = '100' ;
  const z02 = '160' ;
  const z03 = '250' ;
  const z04 = '400' ;
  const z05 = '640' ;
  const z06 = '1000' ;
  const z07 = '1600' ;
  const z08 = '2500' ;
  const z09 = '4000' ;
  const z10 = '6400' ;

  // Variabel nilai Template
  const xLabels = [x00,x01,x02,x03,x04,x05,x06,x07,x08,x09,x10];
  const yLabels = [y00,y01,y02,y03,y04,y05,y06,y07,y08,y09,y10];
  const zLabels = [z00,z01,z02,z03,z04,z05,z06,z07,z08,z09,z10];

  let xIndex = 0, yIndex = 0, zIndex = 0;

  const xDisplay = document.getElementById('x-value');
  const yDisplay = document.getElementById('y-value');
  const zDisplay = document.getElementById('z-value');

  // Axis Move
  function changeValue(axis, delta) {
    if (axis === 'x') {
      //(start sumbu, panjang max)
      xIndex = Math.max(0, Math.min(xIndex + delta, xLabels.length - 1));
      
      xDisplay.textContent = xLabels[xIndex];

      //offset titik temu
      point.position.x = xIndex - 0;
      
      //offset Line Y
      lineY.position.x = xIndex - 0;

      //Line Y Width
      groupLineY.position.x = xIndex - 0;
    }
    if (axis === 'y') {
      //(start sumbu, panjang max)
      yIndex = Math.max(0, Math.min(yIndex + delta, yLabels.length - 1));
      
      yDisplay.textContent = yLabels[yIndex];
      
      //offset titik temu
      point.position.y = yIndex - 0;
      
      //offset Line X
      lineX.position.y = yIndex - 0;

      //Line X Width
      groupLineX.position.y = yIndex - 0;
    }
    if (axis === 'z') {
      zIndex = Math.max(0, Math.min(zIndex + delta, zLabels.length - 1));
      zDisplay.textContent = zLabels[zIndex];

      plane01.position.z = zIndex - 0; // (black01)
      plane02.position.z = zIndex - 0; // (white01)
      
      
      //offset titik temu Line x & Line y, X & Y Plane (yellow)
      point.position.z = zIndex - 0;

      //offset Line y, X & Y Plane (white01)
      lineY.position.z = zIndex - 0;

      //offset Line x, X & Y Plane (white01)
      lineX.position.z = zIndex - 0;



      //offset Axis y, Move Z axis
      axisY.position.z = zIndex - 0;

      //offset Axis x, Move Z axis
      axisX.position.z = zIndex - 0;
      

      //offset Dot, x axis, Move z axis
      xMoveDots.forEach(dot => {
        dot.position.z = zIndex;
      });
      //offset Dot, y axis, Move z axis
      yMoveDots.forEach(dot => {
        dot.position.z = zIndex;
      });

      //X & Y axis width, moving with XY Plane in Z axis
      group2.position.z = zIndex - 0;
      groupLineX.position.z = zIndex - 0;
      groupLineY.position.z = zIndex - 0;

      // Label X dan Y mengikuti posisi Z
      xTextLabels.forEach(lbl => {
        lbl.position.z = zIndex;
      });
      yTextLabels.forEach(lbl => {
        lbl.position.z = zIndex;
      });

    }
  }

  // Three.js Init

  // Kamera
  const width = 860;
  const height = 860;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0D0D0D); // Warna

  const camera = new THREE.PerspectiveCamera(30, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  
  renderer.setSize(width, height);
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  
  document.getElementById('three-container').appendChild(renderer.domElement);
  
  // Posisi kamera awal
  camera.position.set(12.5, 12.5, 30);
  camera.lookAt(scene.position);
  camera.translateX(2); // geser kanan (relatif ke arah kamera)
  camera.translateY(2); // geser atas
  camera.translateZ(10); // maju

  // Cube Plane
  /*
    // XY , Black
  const planeXYGeo = new THREE.PlaneGeometry(10, 10);
  const planeXYMat = new THREE.MeshBasicMaterial({ color: 0x1E1E1E, side: THREE.DoubleSide, transparent: true, opacity: 0.75 });
  const planeXY = new THREE.Mesh(planeXYGeo, planeXYMat);
  planeXY.rotation.y = -Math.PI / 1;
  planeXY.position.z = zIndex - 0.1;
  planeXY.position.x = xIndex + 5;
  planeXY.position.y = yIndex + 5;
  scene.add(planeXY);

  
    // XZ , Black
  const planeXZGeo = new THREE.PlaneGeometry(10, 10);
  const planeXZMat = new THREE.MeshBasicMaterial({ color: 0x1E1E1E, side: THREE.DoubleSide, transparent: true, opacity: 0.75 });
  const planeXZ = new THREE.Mesh(planeXZGeo, planeXZMat);
  planeXZ.rotation.x = -Math.PI / 2;
  planeXZ.position.z = zIndex + 5;
  planeXZ.position.x = xIndex + 5;
  planeXZ.position.y = yIndex - 0.0;
  scene.add(planeXZ);

    // YZ , Black
  const planeYZGeo = new THREE.PlaneGeometry(10, 10);
  const planeYZMat = new THREE.MeshBasicMaterial({ color: 0x1E1E1E, side: THREE.DoubleSide, transparent: true, opacity: 0.75 });
  const planeYZ = new THREE.Mesh(planeYZGeo, planeYZMat);
  planeYZ.rotation.y = -Math.PI / 2;
  planeYZ.position.z = zIndex + 5;
  planeYZ.position.x = xIndex - 0.1;
  planeYZ.position.y = yIndex + 5;
  scene.add(planeYZ);
  */

  // Axis
  function createAxis(length, color, dir) {
    const mat = new THREE.LineBasicMaterial({ color, linewidth: 2 });
    const points = [new THREE.Vector3(), dir.clone().setLength(length)];
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(geo, mat);
    return line;
  }

  scene.add(createAxis(20, 0xF94646, new THREE.Vector3(1,0,0))); // X
  scene.add(createAxis(20, 0x48ED5F, new THREE.Vector3(0,1,0))); // Y
  scene.add(createAxis(20, 0x3160F4, new THREE.Vector3(0,0,1))); // Z

  // Grid Dots
  const dotGeo = new THREE.SphereGeometry(0.1);
  const dotMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

  for (let i = 1; i <= 10; i++) {
    /*
    const xDot = new THREE.Mesh(dotGeo, dotMat);
    xDot.position.set(i - 0, 0, 0);
    scene.add(xDot);

    const yDot = new THREE.Mesh(dotGeo, dotMat);
    yDot.position.set(0, i - 0, 0);
    scene.add(yDot);
    */

    const zDot = new THREE.Mesh(dotGeo, dotMat);
    zDot.position.set(0, 0, i - 0);
    scene.add(zDot);
  }

  // Grid Dots Move
  
  const xMoveDots = []; // array penyimpanan dot sumbu X
  const yMoveDots = [];
  const dotMoveGeo = new THREE.SphereGeometry(0.1);
  const dotMoveMat = new THREE.MeshBasicMaterial({ color: 0x74F7ED }); //cyan

  for (let i = 1; i <= 10; i++) {
    const xDot = new THREE.Mesh(dotMoveGeo, dotMoveMat);
    xDot.position.set(i, 0, zIndex);
    scene.add(xDot);
    xMoveDots.push(xDot);
    
    const yDot = new THREE.Mesh(dotMoveGeo, dotMoveMat);
    yDot.position.set(0, i, zIndex);
    scene.add(yDot);
    yMoveDots.push(yDot);
  }

  // XY Plane

    // 01 , Black
  const plane01Geo = new THREE.PlaneGeometry(10, 10);
  const plane01Mat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide, transparent: true, opacity: 0.75 });
  const plane01 = new THREE.Mesh(plane01Geo, plane01Mat);
  plane01.rotation.y = -Math.PI / 1;
  plane01.position.z = zIndex - 0;
  plane01.position.x = xIndex + 5;
  plane01.position.y = yIndex + 5;
  scene.add(plane01);
  
    //02 , White
  const plane02Geo = new THREE.PlaneGeometry(10, 10);
  const plane02Mat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.15 });
  const plane02 = new THREE.Mesh(plane02Geo, plane02Mat);
  plane02.rotation.y = -Math.PI / 1;
  plane02.position.z = zIndex - 0;
  plane02.position.x = xIndex + 5;
  plane02.position.y = yIndex + 5;
  scene.add(plane02);

  // Moving X Line (based on y)
  const lineXMat = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
  const lineXGeo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, 0, 0),
    new THREE.Vector3(10, 0, 0)
  ]);
  const lineX = new THREE.Line(lineXGeo, lineXMat);
  lineX.rotation.z = 0;
  scene.add(lineX);

  // Moving Y Line (based on x)
  const lineYMat = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
  const lineYGeo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, 0, 0),
    new THREE.Vector3(0, 10, 0)
  ]);
  const lineY = new THREE.Line(lineYGeo, lineYMat);
  scene.add(lineY);

  // X & Y Axis in XY Plane

  // Moving X Axis (based on y)
  const axisXMat = new THREE.LineBasicMaterial({ color: 0xFC72F5 }); //magenta
  const axisXGeo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, 0, 0),
    new THREE.Vector3(14, 0, 0)
  ]);
  const axisX = new THREE.Line(axisXGeo, axisXMat);
  axisX.rotation.z = 0;
  scene.add(axisX);

  // Moving Y Axis (based on x)
  const axisYMat = new THREE.LineBasicMaterial({ color: 0xFC72F5 }); //magenta
  const axisYGeo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, 0, 0),
    new THREE.Vector3(0, 14, 0)
  ]);
  const axisY = new THREE.Line(axisYGeo, axisYMat);
  scene.add(axisY);

  // X & Y Axis Width in XY Plane

  // Grup 1: Tidak bergerak
  const group1 = new THREE.Group();

  // Grup 2: Bisa digerakkan di sumbu Z
  const group2 = new THREE.Group();

  // Grup XY: Bisa digerakkan di sumbu Z & XY Plane
  const groupLineX = new THREE.Group();
  const groupLineY = new THREE.Group();

  // Grup 2: Bisa digerakkan di sumbu Z
  //const group2 = new THREE.Group();

  // Fungsi Axis Width Statis
  function createThickAxis(length, color, dir) {
    const radius = 0.05;
    const geometry = new THREE.CylinderGeometry(radius, radius, length, 8);
    const material = new THREE.MeshBasicMaterial({ color });

    const mesh = new THREE.Mesh(geometry, material);

    // Rotasi silinder ke arah sumbu yang diinginkan
    const defaultAxis = new THREE.Vector3(0, 1, 0); // default: sumbu Y
    const quaternion = new THREE.Quaternion().setFromUnitVectors(defaultAxis, dir.clone().normalize());
    mesh.quaternion.copy(quaternion);

    // Geser silinder agar satu ujung berada di (0,0,0)
    mesh.position.copy(dir.clone().normalize().multiplyScalar(length / 2));

    return mesh;
  }

  // Fungsi Axis Width Move XY Plane
  function createThickAxisLineXY(lengthLineXY, color, dirLineXY) {
    const radiusLineXY = 0.035;
    const geometryLineXY = new THREE.CylinderGeometry(radiusLineXY, radiusLineXY, lengthLineXY, 8);
    const materialLineXY = new THREE.MeshBasicMaterial({ color });

    const meshLineXY = new THREE.Mesh(geometryLineXY, materialLineXY);

    // Rotasi silinder ke arah sumbu yang diinginkan
    const defaultAxisLineXY = new THREE.Vector3(0, 1, 0); // default: sumbu Y
    const quaternionLineXY = new THREE.Quaternion().setFromUnitVectors(defaultAxisLineXY, dirLineXY.clone().normalize());
    meshLineXY.quaternion.copy(quaternionLineXY);

    // Geser silinder agar satu ujung berada di (0,0,0)
    meshLineXY.position.copy(dirLineXY.clone().normalize().multiplyScalar(lengthLineXY / 2));

    return meshLineXY;
  }

    // Axis ke grup 1 (statis)
  group1.add(createThickAxis(13, 0xF94646, new THREE.Vector3(1, 0, 0))); // Axis X
  group1.add(createThickAxis(13, 0x48ED5F, new THREE.Vector3(0, 1, 0))); // Axis Y
  group1.add(createThickAxis(13, 0x3160F4, new THREE.Vector3(0, 0, 1))); // Axis Z

    // Axis ke grup 2 (X & Y move in Z axis)
  group2.add(createThickAxis(12, 0xFC72F5, new THREE.Vector3(1, 0, 0))); // Axis X
  group2.add(createThickAxis(12, 0xFC72F5, new THREE.Vector3(0, 1, 0))); // Axis Y

    // Line X & Y ke grup XY (Line X & Line Y move in Z axis & XY Plane)
  groupLineX.add(createThickAxisLineXY(10, 0xFFFFFF, new THREE.Vector3(1, 0, 0))); // Axis X
  groupLineY.add(createThickAxisLineXY(10, 0xFFFFFF, new THREE.Vector3(0, 1, 0))); // Axis Y

  // Masukkan grup ke dalam scene
  scene.add(group1);
  scene.add(group2);
  scene.add(groupLineX);
  scene.add(groupLineY);
  

  // Intersect Point
  const pointGeo = new THREE.SphereGeometry(0.2);
  const pointMat = new THREE.MeshBasicMaterial({ color: 0xFCB142 });
  const point = new THREE.Mesh(pointGeo, pointMat);
  scene.add(point);

  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }

  // Label  

  function createTextLabelSpriteTransparent({
    text = '',
    fontSize = 64,
    fontFamily = 'Azeret Mono',
    fontWeight = '500',
    textColor = '#ffffff',
    canvasWidth = 256,
    canvasHeight = 128,
    scale = 1,
  } = {}) {
    const canvas = document.createElement('canvas');
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    const ctx = canvas.getContext('2d');

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
    ctx.fillStyle = textColor;
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, canvas.width / 2, canvas.height / 2);

    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.needsUpdate = true;

    const material = new THREE.SpriteMaterial({
      map: texture,
      transparent: true,
    });

    const sprite = new THREE.Sprite(material);
    sprite.scale.set(scale * 2.0, scale, 1); // ukuran label di world unit
    return sprite;
  }

  // Label X (bergerak di sumbu Z)
  const xTextLabels = [];
  xLabels.forEach((label, i) => {
    const sprite = createTextLabelSpriteTransparent({
      text: label,
      fontSize: 32,
      textColor: '#F94646', // red
      scale: 2.0
    });
    sprite.position.set(i - 0.25, -0.5, zIndex); // posisi bawah
    scene.add(sprite);
    xTextLabels.push(sprite);
    sprite.material.rotation = -Math.PI / -4;
  });

  // Label Y (bergerak di sumbu Z)
  const yTextLabels = [];
  yLabels.forEach((label, i) => {
    const sprite = createTextLabelSpriteTransparent({
      text: label,
      fontSize: 40,
      textColor: '#48ED5F', // green
      scale: 1.5
    });
    sprite.position.set(-0.5, i + 0, zIndex); // posisi kiri
    scene.add(sprite);
    yTextLabels.push(sprite);
    sprite.material.rotation = -Math.PI / 24;
  });

  // Label Z (statis, tidak bergerak)
  const zTextLabels = [];
  zLabels.forEach((label, i) => {
    const sprite = createTextLabelSpriteTransparent({
      text: label,
      fontSize: 48,
      textColor: '#3160F4', // blue
      scale: 1.25
    });
    sprite.position.set(-0.75, -0.30, i - 0.65); // pojok kiri bawah
    scene.add(sprite);
    zTextLabels.push(sprite);
    sprite.material.rotation = -Math.PI / 8;
  });

  /*
  // Buat geometry bidang XZ
  const planeXZGeo = new THREE.PlaneGeometry(10, 10);

  // Buat material garis tepi
  const borderMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 }); // linewidth hanya berfungsi di WebGL non-Core

  // Buat edges dari plane
  const edges = new THREE.EdgesGeometry(planeXZGeo);

  // Buat LineSegments (garis pinggir)
  const planeXZBorder = new THREE.LineSegments(edges, borderMat);

  // Rotasi agar rata di bidang XZ
  planeXZBorder.rotation.x = -Math.PI / 2;

  // Posisi sesuai titik tengah plane
  planeXZBorder.position.z = zIndex + 5;
  planeXZBorder.position.x = xIndex + 5;
  planeXZBorder.position.y = yIndex + 10;

  // Tambahkan ke scene
  scene.add(planeXZBorder);
  */

  

  // Grid Plane

  function createGridGroup({
    cellCount = 10,         // jumlah sel (misal: 10x10)
    cellSize = 1,           // ukuran tiap sel (misal: 1 satuan = 1 kotak)
    lineRadius = 0.01,      // ketebalan garis (radius silinder)
    lineColor = 0xffffff,   // warna garis
    verticalAxis = 'z',     // orientasi grid di sumbu Z (XZ), atau Y (XY), dll
  } = {}) {
    const group = new THREE.Group();

    const length = cellCount * cellSize;
    const material = new THREE.MeshBasicMaterial({ 
      color: lineColor,     // warna solid (putih)
      transparent: true,    // aktifkan transparansi
      opacity: 0.15          // nilai 0 (benar-benar transparan) sampai 1 (solid)
      });

    // Grid horizontal (searah X)
    for (let i = 0; i <= cellCount; i++) {
      const geo = new THREE.CylinderGeometry(lineRadius, lineRadius, length, 8);
      const mesh = new THREE.Mesh(geo, material);

      // Rotasi silinder agar memanjang di sumbu X (default silinder tegak di Y)
      mesh.rotation.z = Math.PI / 2;

      // Geser sesuai posisi baris ke-Z
      mesh.position.set(
        length / 2, // tengah X
        0,
        i * cellSize
      );

      group.add(mesh);
    }

    // Grid vertikal (searah Z)
    for (let j = 0; j <= cellCount; j++) {
      const geo = new THREE.CylinderGeometry(lineRadius, lineRadius, length, 8);
      const mesh = new THREE.Mesh(geo, material);

      // Tidak perlu rotasi, default silinder berdiri di Y → rotasi ke X agar jadi vertikal Z
      mesh.rotation.x = Math.PI / 2;

      // Geser sesuai posisi kolom ke-X
      mesh.position.set(
        j * cellSize,
        0,
        length / 2 // tengah Z
      );

      group.add(mesh);
    }

    /*
    // Rotasi seluruh grup jika perlu (misalnya jadi XY atau YZ plane)
    if (verticalAxis === 'y') {
      group.rotation.x = Math.PI / 2;
    } else if (verticalAxis === 'x') {
      group.rotation.z = Math.PI / 2;
    }
    */

    return group;
  }

  // Grid 10x10 di bidang XZ
  const gridXY = createGridGroup({
    cellCount: 10,
    cellSize: 1,
    lineRadius: 0.02,
    lineColor: 0xFFFFFF,
    verticalAxis: 'z', // bisa 'y' atau 'x' juga
  });

    // Offset Grid XZ
  gridXY.position.set(xIndex + 0, yIndex + 10, zIndex + 0 - .01);
  gridXY.rotation.x = Math.PI / 2; // dari bidang XZ → YZ

  scene.add(gridXY);


  // Grid 10x10 di bidang XZ
  const gridXZ = createGridGroup({
    cellCount: 10,
    cellSize: 1,
    lineRadius: 0.02,
    lineColor: 0xFFFFFF,
    verticalAxis: 'z', // bisa 'y' atau 'x' juga
  });

    // Offset Grid XZ
  gridXZ.position.set(xIndex + 0, yIndex + 0, zIndex + 0);

  scene.add(gridXZ);


  // Grid 10x10 di bidang YZ
  const gridYZ = createGridGroup({
    cellCount: 10,
    cellSize: 1,
    lineRadius: 0.02,
    lineColor: 0xFFFFFF,
    verticalAxis: 'z', // bisa 'y' atau 'x' juga
  });

    // Offset Grid YZ
  gridYZ.position.set(xIndex + 0, yIndex + 0, zIndex + 0);
  gridYZ.rotation.z = Math.PI / 2; // dari bidang XZ → YZ

  scene.add(gridYZ);


  animate();
  
</script>



</body>
</html>
